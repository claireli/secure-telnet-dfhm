import socket
import select
import sys
from _thread import *
import telnetlib
import blowfish
import argparse
import time

class Telnet_s_server:
  def __init__(self, host, port, private_key):
    self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    self.ip = host
    self.port = port
    self.private_key = private_key
    self.public_key = 0
    self.cipher = 0
    self.shared_base = 0
    self.shared_modulus = 0
    self.client_threads = []

  def cipher_setup(self, session_key):
    # The key passed in needs to be between 4 and 56 bytes
    session_key=str(session_key)
    if (len(session_key)<4):
      for x in range(4-len(session_key)):
        session_key+=" "
    elif (len(session_key)>56):
      session_key[:56]

    cipher_little = blowfish.Cipher(session_key.encode(), byte_order = "little")
    # This can't be global, otherwise session key will be shared with other threads
    # TODO: fix it!!
    self.cipher = cipher_little

  def generate_session_key(self, client_public_key, shared_modulus):
    return (client_public_key**self.private_key)%shared_modulus

  def decrypt(self, msg):
    msg=msg.decode()
    msg=eval(r'{}'.format(msg))
    msg=self.cipher.decrypt_ecb(msg)
    msg=b"".join(msg)
    msg=msg.decode()

    return msg

  def encrypt(self, msg):
  
    # In order to use blowfish encryption, the message needs to be in a multiple of     8
    if len(msg)<8:
      for x in range(8-len(msg)):
        msg+=" "
    else:
      for x in range(8-(len(msg)%8)):
        msg+=" "
  
    msg=msg.encode()
    #print("msg.encode()", msg, type(msg))
    block=bytearray(msg)
    #print("byte(array)", block, type(block))
    #cipher_little = blowfish.Cipher(b"my key", byte_order = "little")
    #print("encrypt_ecb()", self.cipher.encrypt_ecb(block), type(self.cipher.encrypt    _ecb(block)))
    data_encrypted = b"".join(self.cipher.encrypt_ecb(block))
    #print("data_encrypted", data_encrypted, type(data_encrypted))
  
    #data_decrypted = b"".join(self
    #.cipher.decrypt_ecb(b"".join(self.cipher.encrypt_ecb(block))))
    #data_decrypted = b"".join(self.cipher.decrypt_ecb(data_encrypted))
    #print("data_decrypted", data_decrypted, type(data_decrypted))
  
    return data_encrypted

  def setup(self):
    # this is a socket object, AF_INET is address family for IPv4, SOCK_STREAM is mechanism for 2 way, ordered, unduplicated byte stream
    self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    # bind the socket object to a host & port 
    self.sock.bind((self.ip, int(self.port)))
    self.sock.listen(3)

  def generate_prime():
    # todo: take in a range, and return random prime
    return 5

  def session_shared_primes(self):
    # TODO: call the generate_prime() function
    base = str(5)
    mod = str(23)

    # Set shared values in secure_telent remote object for this thread
    self.shared_base=int(base)
    self.shared_modulus=int(mod)

    # This formatted string will be shared with the client
    return "shared_base:"+base+",shared_modulus:"+mod+"\n"
     
  def client_thread(self,client,client_ip):
    # The Diffie-Hellman-Merkel algorithm starts here
    self.client_threads.append(client)
    print(self.client_threads)
    
    # Generate public prime numbers to share with client
    session_values=self.session_shared_primes()
    client.send(session_values.encode())

    # Generate public key using shared value, share with clients
    self.public_key = (self.shared_base**self.private_key)%self.shared_modulus
    # TODO: Write explanation for the new line
    print("Sending to client our public key: ", self.public_key)
    formatted_public_key = str(self.public_key)+"\n"
    client.send(formatted_public_key.encode())
    
    # Receive client's public key
    client_public_key=int(client.recv(2048).decode())
    print("Client's public key is:", client_public_key)
    
    # This is destroyed upon terminating the client thread
    session_key=self.generate_session_key(client_public_key, self.shared_modulus)
    print("Ephemeral Session Key has been generated:", session_key)
    self.cipher_setup(session_key)
    
    # Two-way channel is now encrypted with our session key generated by the DFHM algorithm
    alive=True
    while alive:
      # <bytes>
      message=client.recv(2048)
      if message:
        print("\n[" + client_ip[0] + "]: " + message.decode()[2:-1])
        data_decrypted = self.decrypt(message)
        print("[" + client_ip[0] + "]: " + data_decrypted)
        
      else:
        self.remove_thread(client, client_ip[0])
        alive=False
      send_to_client = input('telnet secure> ')
      send_to_client = str(self.encrypt(send_to_client)) + "\n"
      #client.send(str(send_to_client).encode())
      client.send(send_to_client.encode())
    exit()

  def remove_thread(self, client, client_ip):

    if client in self.client_threads:
      self.client_threads.remove(client)
    divider(80)
    print (client_ip + " has exited")
    divider(80)
    exit()

# Make the command line look nice with these dividers :P
def divider(n):
  divide=""
  for x in range(n):
    divide+="=" 
  print(divide)

# ============================================================
# Check for valid args on command line
# ============================================================
parser = argparse.ArgumentParser()
parser.add_argument("ip", type=str, help="ip address")
parser.add_argument("port", type=int, help="port")
parser.add_argument("-v","--verbosity", action="count", default=0)
args = parser.parse_args()

ip = str(sys.argv[1])
port = int(sys.argv[2])

try:
  k=open("server.private.key","r")
except IOError:
  print("Error: file server.private.key doesn't exist.")
  exit()

private_key=int(k.read())

# ============================================================
# Set up the secure telnet server
# ============================================================
divider(80)
print("Booting Up Secure Telnet Server")
print("Author: Claire Y. Li\n")
print("Server hosted at: %s:%s" % (ip, port))
secure_server = Telnet_s_server(ip, port, private_key)
secure_server.setup()

# ============================================================
# Wait for client(s) to connect
# ============================================================
while True:

  # We have a visitor
  client, client_ip = secure_server.sock.accept()
  print(client_ip)
  
  # Log into the global thread tracker
  secure_server.client_threads.append(client)

  # Announcement
  divider(80)
  print(client_ip[0] + " connected")
  divider(80)

  # Set up two-way encrypted TCP tunnel
  start_new_thread(secure_server.client_thread,(client,client_ip)) 

  # TODO: if user inputs shutdown, close server, log off

client.close()
server.close()
