import socket
import _thread
import datetime

DIVIDER = 80
SERVER_LOG_PATH = 'telnet-secure-communication-record.log'
EOT = '\x04'

class TelnetSecureServer:
  def __init__(self, port, private_key):
    self.port = port
    self.host = self.set_host()
    self.private_key = private_key
    self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    self.client_threads = []
    self.client_sessions = {}
    self.server_logging = True

  def run(self):
    self.setup()

    if self.server_logging:
      self.server_logger(f'{self.msg_timestamp()}\nServer running at {self.host}:{self.port}\n')

    while True:
      client, client_ip = self.sock.accept()
      self.client_connection(client, client_ip)

  def set_host(self):
    return '127.0.0.1'

  def format_new_login_msg(self, msg):
    divider = ''.join(['-' for i in range(DIVIDER)])
    formatted_msg = f'{divider}\n{self.msg_timestamp()}\n{msg}\n{divider}\n'
    return formatted_msg

  def format_msg(self, msg, id):
    formatted_msg = f'{self.msg_timestamp()} -- [{id}]: {msg}\n'
    return formatted_msg

  def msg_timestamp(self):
      return datetime.datetime.now().strftime('%m/%d/%Y, %H:%M')

  def setup(self):
    try:
      # AF_INET is address family for IPv4,
      # SOCK_STREAM is mechanism for 2 way, ordered, unduplicated byte stream
      self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
      self.sock.bind((self.host, self.port))
      self.sock.listen(3)
    except Exception as msg:
      print(f'ERROR: socket setup failure. Exiting now.\n')
      print(msg)
      exit()

  def client_connection(self, client, client_ip):
    _thread.start_new_thread(self.client_thread,(client,client_ip))

  def get_active_connections(self):
    print(f"{self.msg_timestamp()} -- Active connections [{len(self.client_sessions.keys())}] : {', '.join(con for con in self.client_sessions.keys())}")

  def client_disconnect(self, client, id):

    print(f'{self.msg_timestamp()} -- Disconnecting thread: {id}')

    if id in self.client_sessions.keys():
      del self.client_sessions[id]

    if client in self.client_threads:
      self.client_threads.remove(client)

  def server_logger(self, msg):
      try:
          with open(SERVER_LOG_PATH, 'a') as server_log:
              server_log.write(msg)
      except IOError:
          print(f'ERROR: could not access valid log file at {SERVER_LOG_PATH}.')

  def update_chat_sessions(self, msg):
      for client_id in self.client_sessions.keys():
          self.client_sessions[client_id] += msg

  def get_client_id(self, client):
    return f'{client.getpeername()[0]}:{client.getpeername()[1]}'

  def broadcast(self, message, sender_id, login_event=False):
    # message needs to get added to each session dictionary then sent to each client
    if login_event:
      msg = self.format_new_login_msg(message)
    else:
      msg = self.format_msg(message, sender_id)

    self.update_chat_sessions(msg)

    for client in self.client_threads:
      # get the clients latest session messages
      id = self.get_client_id(client)
      client.send(f'{self.client_sessions[id]}{EOT}'.encode())

    if self.server_logging:
      self.server_logger(msg)

  def client_thread(self, client, client_ip):
    id = self.get_client_id(client)
    self.client_threads.append(client)
    self.client_sessions[id] = ''

    self.broadcast(f'{id} has entered the channel.', id, True)
    print(f'{self.msg_timestamp()} -- Connecting thread: {id}')
    self.get_active_connections()

    # Two-way channel is now encrypted with our session key generated by the DFHM algorithm
    alive=True
    while alive:
        # <bytes>
        message=client.recv(2048)
        if message:
            self.broadcast(message, id)
            #print("\n[" + client_ip[0] + "]: " + message.decode()[2:-1])
            #data_decrypted = self.decrypt(message)
            #print("[" + client_ip[0] + "]: " + data_decrypted)

        else:
            self.broadcast(f'{id} has exited the channel.', id, True)
            self.get_active_connections()
            self.client_disconnect(client, id)
            self.get_active_connections()
            alive=False

            #send_to_client = input('telnet secure> ')
            #send_to_client = str(self.encrypt(send_to_client)) + "\n"
            #client.send(str(send_to_client).encode())
            #client.send(send_to_client.encode())
            exit()

if __name__ == '__main__':
    TSS = TelnetSecureServer(9090, 'server.private.key')
    TSS.run()
